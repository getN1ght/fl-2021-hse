%{
#include <iostream>
#include <string>
#include <map>
#include <cstdlib>
#include <unordered_map>
#include <regex>
#include <vector>
#include <stdexcept>

int yylex(); 
int yyerror(const char *p) { 
    std::cerr << "Syntax error" << std::endl;
    exit(1);
}


namespace parser {
    
    struct unavailible_name_exception : std::logic_error {
        unavailible_name_exception(const std::string& e): logic_error(e) {}
    };

    struct link_exception : std::logic_error {
        link_exception(const std::string& e): logic_error(e) {}
    };

    struct state_exception: std::logic_error {
        state_exception(const std::string& e): logic_error(e) {}
    };



    struct Node {
        bool is_terminal = 0;
        std::unordered_map<std::string, Node*> links;
        
        std::vector<int> used_symbols;

        explicit Node(bool is_terminal) : is_terminal(is_terminal), used_symbols(100, 0) {
        }
        
    };

    std::unordered_map<std::string, Node*> used_names;
    Node* beginning = nullptr;

    static void add_id(const std::string& id, bool is_beginnning, bool is_terminal) {
        
        if (used_names.count(id)) {
            throw unavailible_name_exception("Repeated name \"" + id + "\"");
        }

        if (is_beginnning) {
            if (beginning) {
                throw state_exception("Multiple beginning states");
            }
            else {
                beginning = new Node(is_terminal);
                used_names[id] = beginning;
            }
        }
        else {
            used_names[id] = new Node(is_terminal);
        }
        
    }

    static void add_link(const std::string& id1, const std::string &link, const std::string& id2) {
        if (used_names.count(id1) == 0 || used_names.count(id2) == 0) {
            throw unavailible_name_exception("No states with this name: \"" +
                (used_names.count(id1) == 0 ? id1 : id2) + "\"");
        }

        if (used_names[id1]->links.count(id2)) {
            std::regex reg("[" + link + "]");
            
            auto mark_as_used = [&](char from, char to) {
                for (char c = from; c <= to; ++c) {
                    if (regex_match(std::string({c}), reg)) {
                        if (used_names[id1]->used_symbols[c]) {
                            throw link_exception("Link " + std::string({c}) + " is ambiguous");
                        }
                        else {
                            used_names[id1]->used_symbols[c] = 1;
                        }
                    }
                }
            };

            mark_as_used('0', '9');
            mark_as_used('a', 'z');
            mark_as_used('A', 'Z');
        }
        
        used_names[id1]->links[link] = used_names[id2];
    }

    static std::string buf;

    static bool is_match(Node* current_node, const char* str) {
        if (!current_node) {
            return 0;
        }

        if (*str == '\0') {
            return current_node->is_terminal;
        }

        for (auto it: current_node->links) {
            std::regex reg("[" + it.first + "]");
            if (regex_match(std::string({str[0]}), reg)) {
                return is_match(it.second, str + 1);
            }
        }

        return 0;
    }

    static char* construct(const char *from, char c) {
        int pos = std::strlen(from);
        char *dest = new char[std::strlen(from) + 1];
        strcpy(dest, from);
        dest[pos] = c;
        return dest;
    }

    static bool check_fullness() {
        bool ans = 1;
        for(auto it: used_names) {
            
            auto check_interval = [&](char from, char to) {
                bool correct = 1;
                for (char c = from; c <= to; ++c) {
                    correct &= it.second->used_symbols[c];
                }
                return correct;
            };

            ans &= check_interval('0', '0');
            ans &= check_interval('a', 'z');
            ans &= check_interval('A', 'Z');
        }
        return ans;
    }
}

%}


%union {
    char* word;
    char sym;
}

%token <word> KEY_STATES KEY_LINKS ID SPEC_BEGIN SPEC_TERMINAL BRACKET_OPEN BRACKET_CLOSE
%token <sym> CHAR COLON TAB 
%type <word> arrow string

%%

start: dfa {}

dfa: init_states init_links {}

init_states: KEY_STATES ID COLON states { }
| KEY_STATES COLON states {}

states: TAB SPEC_BEGIN ID states {  parser::add_id($3, true, false); }
| TAB SPEC_BEGIN ID {  parser::add_id($3, true, false); }
| TAB SPEC_BEGIN SPEC_TERMINAL ID states {  parser::add_id($4, true, true); }
| TAB SPEC_BEGIN SPEC_TERMINAL ID {  parser::add_id($4, true, true); }
| TAB SPEC_TERMINAL SPEC_BEGIN ID states { parser::add_id($4, true, true); }
| TAB SPEC_TERMINAL SPEC_BEGIN ID {  parser::add_id($4, true, true); }
| TAB SPEC_TERMINAL ID states {  parser::add_id($3, false, true); }
| TAB SPEC_TERMINAL ID {  parser::add_id($3, false, true); }
| TAB ID states {  parser::add_id($2, false, false); }
| TAB ID {  parser::add_id($2, false, false); }

init_links: KEY_LINKS ID COLON links {}
| KEY_LINKS COLON links {}

links: TAB ID arrow ID links {  parser::add_link($2, $3, $4); }
| TAB ID arrow ID { parser::add_link($2, $3, $4); }

arrow: BRACKET_OPEN string BRACKET_CLOSE { $$ = $2; }

string: string CHAR { $$ = parser::construct($$, $2); }
| CHAR { $$ = parser::construct("\0", $1); }

%%




int main(int argc, char** argv) {
    if (freopen(argv[1], "r", stdin)) {
        yyparse();
        fclose(stdin);
    }
    else {
        std::cerr << "Can not open " << argv[1] << std::endl;
        return 1;
    }

    std::string buf;
    if(freopen(argv[2], "r", stdin)) {
        std::cin >> buf;
        fclose(stdin);
    }
    else {
        std::cerr << "Can not open " << argv[2] << std::endl;
        return 1;
    }

    try {
        std::cout << (parser::is_match(parser::beginning, buf.c_str()) ? "Valid" : "Invalid"); 
        if (!parser::check_fullness()) {
            std::cerr << ", but automata is not full";
        }
        std::cout << std::endl;

        return 0;
    }
    catch(const parser::state_exception &e) {
        std::cerr << e.what() << std::endl; 
    }
    catch(const parser::link_exception &e) {
        std::cerr << e.what() << std::endl; 
    }
    catch(const parser::unavailible_name_exception &e) {
        std::cerr << e.what() << std::endl; 
    }

    return 1;
}
