%{
#include <iostream>
#include <string>
#include <map>
#include <cstdlib>
#include <unordered_map>
#include <regex>
using namespace std;

int yylex(); 
int yyerror(const char *p) { cerr << "Error!" << endl; return 1; }

namespace parser {
    struct Node {
        bool is_terminal = 0;
        std::unordered_map<std::string, Node*> links;
        explicit Node(bool is_terminal) : is_terminal(is_terminal) {
            
        }
    };

    std::unordered_map<std::string, Node*> used_names;
    Node* beginning = nullptr;

    static void add_id(const std::string& id, bool is_beginnning, bool is_terminal) {
        
        if (used_names.count(id)) {
            exit(1);
        }

        if (is_beginnning) {
            if (beginning) {
                exit(1);
            }
            else {
                beginning = new Node(is_terminal);
                used_names[id] = beginning;
            }
        }
        else {
            used_names[id] = new Node(is_terminal);
        }
        
    }

    static void add_link(const std::string& id1, const std::string &link, const std::string& id2) {
        if (used_names.count(id1) == 0 || used_names.count(id2) == 0) {
            exit(1);
        }

        if (used_names[id1]->links.count(id2)) {
            exit(1);
        }
        else {
            used_names[id1]->links[link] = used_names[id2];
        }
    }

    static std::string buf;

    static bool is_match(Node* current_node, const char* str) {
        if (!current_node) {
            return 0;
        }

        if (*str == '\0') {
            return current_node->is_terminal;
        }

        for (auto it: current_node->links) {
            std::regex reg("[" + std::string(it.first) + "]");
            
            if (regex_match(std::string({str[0]}), reg)) {
                
                return is_match(it.second, str + 1);
            }
        }

        return 0;
    }

    static char* construct(const char *from, char c) {
        int pos = std::strlen(from);
        char *dest = new char[std::strlen(from) + 1];
        strcpy(dest, from);
        dest[pos] = c;
        return dest;
    }
}

%}


%union {
    char* word;
    char sym;
}

%token <word> KEY_STATES KEY_LINKS ID SPEC_BEGIN SPEC_TERMINAL BRACKET_OPEN BRACKET_CLOSE
%token <sym> CHAR COLON TAB 
%type <word> arrow string

%%

start: dfa {}

dfa: init_states init_links {}

init_states: KEY_STATES ID COLON states { }
| KEY_STATES COLON states {}

states: TAB SPEC_BEGIN ID states {  parser::add_id($3, true, false); }
| TAB SPEC_BEGIN ID {  parser::add_id($3, true, false); }
| TAB SPEC_BEGIN SPEC_TERMINAL ID states {  parser::add_id($4, true, true); }
| TAB SPEC_BEGIN SPEC_TERMINAL ID {  parser::add_id($4, true, true); }
| TAB SPEC_TERMINAL SPEC_BEGIN ID states { parser::add_id($4, true, true); }
| TAB SPEC_TERMINAL SPEC_BEGIN ID {  parser::add_id($4, true, true); }
| TAB SPEC_TERMINAL ID states {  parser::add_id($3, false, true); }
| TAB SPEC_TERMINAL ID {  parser::add_id($3, false, true); }
| TAB ID states {  parser::add_id($2, false, false); }
| TAB ID {  parser::add_id($2, false, false); }

init_links: KEY_LINKS ID COLON links {}
| KEY_LINKS COLON links {}

links: TAB ID arrow ID links {  parser::add_link($2, $3, $4); }
| TAB ID arrow ID { parser::add_link($2, $3, $4); }

arrow: BRACKET_OPEN string BRACKET_CLOSE { $$ = $2; }

string: string CHAR { $$ = parser::construct($$, $2); }
| CHAR { $$ = parser::construct("\0", $1); }

%%




int main(int argc, char** argv) {
    if (freopen(argv[1], "r", stdin)) {
        yyparse();
        fclose(stdin);
    }

    std::string buf;
    if(freopen(argv[2], "r", stdin)) {
        std::cin >> buf;
        fclose(stdin);
    }
    
    
    std::cout << (parser::is_match(parser::beginning, buf.c_str()) ? "Valid" : "Invalid") << endl; 

    return 0;
}
